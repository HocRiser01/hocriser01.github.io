<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="robots" content="noindex, nofollow">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"47.99.133.133","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="文中标明【11】的为C++11新增标准。 第零部分 第一章 开始  C++是静态（编译时检查变量类型）、弱类型（会自动做隐式类型转换）； cin &gt;&gt;和cout &lt;&lt; 运算顺序均为从左至右，运算结果为一个istream&#x2F;ostream对象； while (cin &gt;&gt; a) 在读到EOF 时跳出循环； 由于&#x2F;* *&#x2F; 注释的判定为遇到第一个*&#x2F; 结束，因此该注释">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer读书笔记">
<meta property="og:url" content="http://47.99.133.133/2023/07/21/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="朝汐">
<meta property="og:description" content="文中标明【11】的为C++11新增标准。 第零部分 第一章 开始  C++是静态（编译时检查变量类型）、弱类型（会自动做隐式类型转换）； cin &gt;&gt;和cout &lt;&lt; 运算顺序均为从左至右，运算结果为一个istream&#x2F;ostream对象； while (cin &gt;&gt; a) 在读到EOF 时跳出循环； 由于&#x2F;* *&#x2F; 注释的判定为遇到第一个*&#x2F; 结束，因此该注释">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-22T00:14:08.000Z">
<meta property="article:modified_time" content="2025-07-04T11:36:01.145Z">
<meta property="article:author" content="HocRiser">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://47.99.133.133/2023/07/21/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++ Primer读书笔记 | 朝汐</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">朝汐</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">如星空般深蓝</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fa fa-image fa-fw"></i>Gallery</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/HocRiser01" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://47.99.133.133/2023/07/21/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="HocRiser">
      <meta itemprop="description" content="平凡即是喜乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝汐">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 20:14:08" itemprop="dateCreated datePublished" datetime="2023-07-21T20:14:08-04:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-04 07:36:01" itemprop="dateModified" datetime="2025-07-04T07:36:01-04:00">2025-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>22 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>文中标明【11】的为C++11新增标准。</p>
<h2 id="第零部分">第零部分</h2>
<h3 id="第一章-开始">第一章 开始</h3>
<ul>
<li>C++是静态（编译时检查变量类型）、弱类型（会自动做隐式类型转换）；</li>
<li><code>cin &gt;&gt;</code>和<code>cout &lt;&lt;</code>
运算顺序均为从左至右，运算结果为一个istream/ostream对象；</li>
<li><code>while (cin &gt;&gt; a)</code> 在读到<code>EOF</code>
时跳出循环；</li>
<li>由于<code>/* */</code> 注释的判定为遇到第一个<code>*/</code>
结束，因此该注释不能嵌套。一般只用它来写注释，需要注释掉代码时使用多行<code>//</code>；</li>
<li><code>cerr</code>不可重定向，不通过缓冲区；<code>endl</code>会刷新缓冲区；</li>
<li>Windows下文件结束符为<code>Ctrl+Z</code>后<code>Enter</code>，Linux下为<code>Ctrl+D</code>；</li>
<li>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头；</li>
</ul>
<span id="more"></span>
<h2 id="第一部分-c基础">第一部分 C++基础</h2>
<h3 id="第二章-变量和基本类型">第二章 变量和基本类型</h3>
<ul>
<li>不同编译器字长和实现方式均不同，不要混用有符号和无符号变量；</li>
<li>赋给带符号类型一个超出其表示范围的值是ub（未定义行为）；</li>
<li>字面值常量：编译期可以直接得到结果的常量，如整数<code>1</code>、字符<code>’a’</code>、字符串<code>”a”</code>、布尔<code>true</code>、指针<code>nullptr</code>等；</li>
<li>【11】初始化和赋值不一样；C++11支持列表初始化，可以初始化类或数组等，在可能造成数据丢失时会警告；</li>
<li>全局变量会被默认初始化，而函数体内置类型变量不会；</li>
<li>作为静态类型语言，且为了支持分离式编译，C++区分了声明和定义；允许多次声明（当然声明必须一样），但定义只能有一次；</li>
<li>复合类型（引用、指针）由基本数据类型（如int）和声明符（*和&amp;）列表组成；</li>
<li><code>int *a，b</code>此时b为整型，因此声明时建议将声明符列表紧挨变量名；</li>
<li>【11】C++11用<code>nullptr</code>（字面值）带出原先的预处理变量<code>NULL</code>，以防止函数重载后无法分清参数是0还是NULL；</li>
<li><code>void *</code>指针没有对象类型信息，不能解引用；</li>
<li>常量引用<code>const &amp;</code>必须在声明时初始化；</li>
<li>顶层const表示指针本身是常量（const
pointer）：<code>int * const</code>；底层const表示指针所指对象为常量（pointer
to
const）：<code>const int *</code>；此处国内叫法（常量指针）似乎不一致，建议直接使用英文；</li>
<li>读声明时可以从右向左读，左边是右边的定语；</li>
<li>【11】<code>constexpr</code>表示编译时常量，即可以直接由字面值简单运算得到；相应地有运行时常量，如用一个变量初始化常量；</li>
<li>【11】C++11规定了新方法：别名声明<code>using new_type_name = old_type_name;</code></li>
<li>不应将<code>typedef</code>后的类型简单带入到新声明中，如<code>typedef char * pstring; const pstring cstr;</code>中<code>cstr</code>的基本数据类型为指针，此为const
pointer，而简单带入成<code>const char * cstr</code>后基本数据类型变为<code>const char</code>，<code>*</code>成为声明符的一部分，变为pointer
to const；</li>
<li>【11】定义<code>auto</code>类型时必须初始化，否则编译期无法推导类型；<code>auto</code>一般会忽略顶层const，若需要应写明<code>const auto</code>；</li>
<li>【11】<code>decltype(f()) sum = x;</code>
用<code>f()</code>的返回值类型作为<code>sum</code>的推导类型，但不实际计算<code>f()</code>，<code>sum</code>由<code>x</code>初始化；</li>
<li>设<code>int i = 42, *p = &amp;i, &amp;r = i;</code>则<code>decltype(*p)</code>的结果是<code>int&amp;</code>而非<code>int</code>，<code>decltype(r)</code>结果为<code>int&amp;</code>，<code>decltype(r + 0)</code>的结果为<code>int</code>；<code>decltype</code>的表达式若是加上括号的变量，结果将是引用，如<code>decltype((i))</code>会得到引用；其余情况均会将引用理解为变量别名，除了<code>decltype</code>的时候；</li>
<li>头文件保护符：在代码首尾分别加上<code>#ifndef A_H    #define A_H</code>和<code>#endif</code>；</li>
<li><code>typedef int i1, *i2;</code>定义了一个<code>int</code>类型和一个<code>int*</code>类型；</li>
</ul>
<h3 id="第三章-字符串向量和数组">第三章 字符串、向量和数组</h3>
<ul>
<li>头文件不应包含using声明；</li>
<li>若用=号初始化则为拷贝初始化，否则为直接初始化；</li>
<li><code>getline(cin, s)</code>会读到一个<code>'\n'</code>为止（包括此<code>'\n'</code>但<code>s</code>中不存）；</li>
<li>【11】范围（range）for语句：<code>for (declaration: expression)</code>
如<code>for (auto &amp;c: str)</code>；</li>
<li>有些老式编译器要求<code>vector&lt;vector&lt;int&gt; &gt;</code>此处必须有空格；</li>
<li><code>const_iterator</code> 是pointer to
const；<code>auto it = v.cbegin();</code>
会得到一个<code>const_iterator</code>；</li>
<li>但凡使用了迭代器的循环体都不要向所属容器添加元素；</li>
<li>迭代器可以和整数相加减；两个同容器的迭代器也可以相减，得到二者的距离，结果为有符号整型<code>difference_type</code>；两个指向同一数组中元素的指针相减的结果为有符号整型<code>ptrdiff_t</code>；</li>
<li>引用不是对象，故不存在引用的数组；</li>
<li>读数组的声明：由内而外，优先右结合，其次左结合；</li>
<li>数组下标为无符号整型<code>size_t</code>；数组定义的维度必须是编译期常量；</li>
<li>当使用数组名时往往会被编译器转换为数组首地址（<code>decltype</code>时不会），如<code>string *p = arr;</code>等价于<code>string *p = &amp;arr[0];</code></li>
<li>多维数组使用范围for语句时需要所有外层都使用引用<code>for (auto &amp;i: arr)</code>，否则会被编译器理解为数组首地址；</li>
<li>指针也是迭代器；尾后迭代器<code>end()</code>
没有实际含义，不能被递增或解引用；</li>
<li>【11】C++11支持数组的<code>begin(arr)</code>和<code>end(arr)</code>函数；</li>
<li>指向数组元素的指针也可以当数组用：<code>int *p = &amp;arr[2]; p[-1];</code></li>
<li><code>strlen(str)</code>会一直找到空字符为止，所以可能产生缓冲区错误；</li>
<li><code>string::c_str()</code>返回一个<code>const char *</code>，不保证一直有效；</li>
<li>用数组初始化vector：<code>vector&lt;int&gt; ivec(begin(arr), end(arr));</code></li>
<li>优先使用string和vector而减少使用C风格的字符串和数组；</li>
</ul>
<h3 id="第四章-表达式">第四章 表达式</h3>
<ul>
<li>【11】C++11允许直接使用初始化列表赋值、传参、作函数返回值；</li>
<li>新版C++正负均向零舍入；</li>
<li>赋值运算符具有右结合律；非必要不使用后置递增递减算符，因为会对迭代器产生较大不必要运算；</li>
<li><code>,</code> 运算符从左至右运算，并只返回最后一项；</li>
<li>无符号类型与带符号类型的运算会进行依赖于编译器的算数转换，故不要使用；</li>
<li><code>static_cast</code>为不报警告的强制类型转换，如<code>void* p = &amp;d; double *dp = static_cast&lt;double*&gt;(p);</code></li>
<li><code>const_cast</code>改变运算对象的底层const，转换本身是常量的对象是ub；示例用法：<code>const char *pc; char *p = const_cast&lt;char*&gt;(pc);</code></li>
<li><code>reinterpret_cast</code>重新解释位模式，示例：<code>int *ip; char *pc = reinterpret_cast&lt;char*&gt;(ip);</code>
尽量不要使用此强制转换；</li>
<li>尽量使用C++风格的类型转换而非C风格的(type)var；</li>
<li>提倡使用<code>*p++</code>，递增运算符优先级高于解引用；</li>
</ul>
<h3 id="第五章-语句">第五章 语句</h3>
<ul>
<li><code>else</code>默认匹配最近的没有<code>else</code>的<code>if</code>；</li>
<li><code>case</code>的值必须是整型常量表达式（字符算整型）；<code>case</code>语句会一直执行直至遇到<code>break</code>；</li>
<li>异常类只有一个成员函数<code>what()</code>，返回<code>const char *</code>，提供异常文本信息；</li>
</ul>
<h3 id="第六章-函数">第六章 函数</h3>
<ul>
<li>函数调用的这对括号叫调用运算符；局部变量、形参等离开作用域自动销毁的变量称为自动对象；</li>
<li>函数最外层作用域中的局部变量不能与形参重名；</li>
<li>最佳实践：定义函数的源文件应包含声明函数的头文件；尽量使用常量引用作为形参；</li>
<li>C++允许用字面值初始化常量引用；</li>
<li>【11】实参数量未知但类型都相同，C++11支持<code>initializer_list</code>类型，内存常量值，用法类似<code>vector</code>：<code>initializer_list&lt;T&gt; lst&#123;a, b, c&#125;;</code>
如：<code>void msg(initializer_list&lt;string&gt; il)&#123; … &#125;</code>，调用：<code>msg(&#123;"a", "b"&#125;</code>；</li>
<li>省略符形参<code>...</code>只能用于形参列表的最后一个，且仅用于C和C++通用的类型；</li>
<li>不使用<code>typedef</code>让函数返回数组指针：<code>Type (*function(parameter_list))[dimension]</code>
，或使用<code>decltype(arr) *arrPtr(int i)</code>，<code>*</code>表示返回数组指针（这点函数指针同理）。</li>
<li>【11】尾置返回类型： <code>auto func(int i) -&gt; int(*)[10];</code></li>
<li>默认实参必须是全局定义，其值取决于调用时对应实参的值；</li>
<li><code>constexpr</code>函数不一定返回常量表达式，只要编译期能得到值即可；</li>
<li><code>assert</code>预处理宏依赖于<code>NDEBUG</code>预处理变量，编译参数加入NDEBUG等价于<code>#define NDEBUG</code></li>
<li>预处理器定义的5个程序调试用的名字：<code>__func__</code>、<code>__FILE__</code>、<code>__LINE__</code>、<code>__TIME__</code>、<code>__DATE__</code></li>
<li>函数指针：用指针替换函数名即可，如<code>bool (*pf)(const int &amp;);</code>，函数指针可以作为形参；</li>
<li>当把函数名作为值使用时，自动转换成函数指针（即<code>pf = func</code>等价于<code>pf = &amp;func</code>），调用时也会自动解引用（即<code>bool b = pf(1);</code>等价于<code>bool b = (*pf)(1);</code>）</li>
<li>函数类型的形参会被自动转换为指针：<code>void func(bool pf());</code>等价于<code>void func(bool (*pf)());</code>
；使用<code>decltype(func) *</code>定义函数指针；</li>
<li>相反，函数返回值不会做自动转换，必须指明返回一个函数指针；</li>
<li>局部静态变量一般拥有和全局变量同等地位和处理方式；</li>
<li>内联函数、函数重载部分略；</li>
</ul>
<h3 id="第七章-类">第七章 类</h3>
<ul>
<li><code>constexpr</code>函数和定义在类内的函数都是隐式<code>inline</code>函数；</li>
<li><code>this</code>指针是一个<code>Type * const</code>，若需要对常量对象执行成员函数，可以在函数参数列表的最后加上<code>const Type * const this</code>；仅在使用整体而非访问部分成员的时候使用<code>this</code>；</li>
<li>类内函数定义顺序不影响，编译期先处理成员声明，再处理函数体（类外有影响）；但是类内声明之间有顺序，如当一个函数使用类型<code>Type</code>时，必须之前已经定义此<code>Type</code>类型。</li>
<li>只有当类没有声明任何构造函数时才会自动生成默认构造函数（且若有其它成员类且该类没有默认构造函数或其它特殊情况，则无法自动生成）；</li>
<li>【11】可以<code>= default</code>使用默认构造函数，若此定义在内部则为内联，否则不是；</li>
<li><code>struct</code>和<code>class</code>的唯一区别是默认访问控制，前者是<code>private</code>后者是<code>public</code>；</li>
<li>一个可变数据成员<code>mutable</code>即使是<code>const</code>对象成员也不是<code>const</code>；</li>
<li>友元声明：<code>friend</code>后接声明即可（并非真正的声明）；外类的友元函数要写对应类<code>classtype::</code>；若有函数重载则每种均应分别声明；</li>
<li>若类中已使用外层作用域定义的类型，则类内不可再定义此类型覆盖外层定义；</li>
<li>构造函数初始化列表为初始化，但函数体内为赋值；若一个成员变量同时在定义时被初始化和在初始化列表中，则以初始化列表为准（不推荐）；<code>const</code>或引用类型必须初始化；</li>
<li>委托构造函数，即直接在初始化列表调用其它构造函数：<code>Type():Type(...)&#123;...&#125;</code>，此处<code>Type()</code>委托了<code>Type(...)</code>；</li>
<li>函数传参遵循最佳匹配原则，不匹配时会做一次（且仅一次）类类型转换；</li>
<li>用初始化列表初始化类时需要所有成员均为<code>public</code>；</li>
<li>字面值常量类必须定义至少一个<code>constexpr</code>的构造函数，而普通类不能定义<code>const</code>的构造函数；</li>
<li>应该在类外部定义静态成员，但需要在类内声明<code>static</code>；类外定义可以访问类的私有成员；</li>
<li><code>static constexpr int period = 30;</code>
进行了声明和初始化，但没有进行定义，最好在类外再定义一下；</li>
<li>前向声明暂时不进行定义，可以用来定义指针或引用，或声明以它为参数或返回类型的函数；声明之后定义之前的类型叫作不完全类型；</li>
<li>静态成员类型可以是不完全类型，也可以就是它所属的类类型，而非静态成员只能声明成它所属类的指针或引用；</li>
</ul>
<h2 id="第二部分-c标准库">第二部分 C++标准库</h2>
<h3 id="第八章-io库">第八章 IO库</h3>
<ul>
<li><code>ifstream</code>（头文件<code>fstream</code>）和<code>istringstream</code>（头文件<code>sstream</code>）继承自<code>istream</code>（头文件<code>iostream</code>），输出同理；故使用<code>cin</code>的地方均可以使用自定义的<code>ifstream</code>和<code>istringstream</code>对象代替；</li>
<li>IO对象无拷贝和赋值；使用<code>&lt;&lt; flush</code>可以刷新缓冲区；当<code>fstream</code>对象被销毁时会自动调用<code>close</code>；</li>
<li>高级IO操作略；</li>
</ul>
<h3 id="第九章-顺序容器">第九章 顺序容器</h3>
<ul>
<li>【11】<code>array&lt;type, size&gt;</code>可以灵活指定大小，支持赋值和复制（因此可以直接作为函数参数或返回值），也支持迭代器、内置方法，提供更好的类型安全检查（<code>std::out_of_range</code>异常）；</li>
<li>顺序容器提供<code>arr.assign(begin, end)</code>
进行赋值，但传入的迭代器不能指向调用者本身；</li>
<li>除<code>array</code>外的<code>swap()</code>函数都是只交换指针；<code>array</code>交换整体，但可以用<code>std::swap()</code>实现交换指针；建议统一使用非成员版本的<code>std::swap()</code>；</li>
<li>【11】C++11中接受元素个数或范围的<code>insert</code>返回指向第一个新加入元素的迭代器（旧版本返回<code>void</code>），<code>erase()</code>返回被删元素之后元素的迭代器；同样<code>insert</code>的参数不能指向调用者容器；<code>insert()</code>不能使用初始化列表；</li>
<li><code>emplace_front()</code>、<code>emplace()</code>和<code>emplace_back()</code>分别是<code>push_front()</code>、<code>insert()</code>和<code>push_back()</code>的构造函数而非拷贝构造函数版本；</li>
<li>访问成员函数<code>front()</code>、<code>back()</code>、下标<code>[]</code>和<code>at()</code>返回的都是引用；下标不做安全检查，超出范围为ub，<code>at(n)</code>越界返回<code>std::out_of_range()</code>；</li>
<li>【11】C++11实现了高效简单的<code>forward_list</code>单向链表，仅支持<code>before_begin()</code>、<code>insert_after()</code>、<code>emplace_after()</code>和<code>erase_after()</code>；</li>
<li>不要保存<code>end()</code>，因为在添加删除元素时原先<code>end()</code>会失效，<code>end()</code>操作很快；</li>
<li><code>resize()</code>和<code>reserve()</code>不会减少容器占用的内存空间，而C++11的<code>shrink_to_fit()</code>可以（但不保证退回内存）；</li>
<li>容器适配器<code>stack</code>和<code>queue</code>默认基于<code>deque</code>实现，可以指明使用除<code>array</code>外任何容器构造<code>stack</code>，以及用<code>list</code>或<code>deque</code>（不能用<code>vector</code>）构造<code>queue</code>
，如<code>stack&lt;string, vector&lt;string&gt;&gt;</code>；</li>
</ul>
<h3 id="第十章-泛型算法">第十章 泛型算法</h3>
<ul>
<li>迭代器令算法不依赖于容器而是依赖于元素类型的操作，泛型算法永远不会执行容器的操作，只会运行与迭代器之上；</li>
<li>【11】lambda表达式：<code>[capture list](parameter list) -&gt; return type &#123;...&#125;</code>
参数列表和返回类型可省略（代表指定空参数列表和自动推断返回类型）；捕获值在lambda创建时而非调用时拷贝，引用捕获需要保证对应变量存在；</li>
<li><code>[]</code>不捕获变量；<code>[names]</code>规定捕获列表，默认为值拷贝，加<code>&amp;</code>表示引用捕获；<code>[&amp;]</code>和<code>[=]</code>表示自动隐式捕获；<code>[&amp;, identifier_list]</code>和<code>[=, identifier_list]</code>，后者变量前必须加&amp;；</li>
<li>若函数体包含<code>return</code>外任何语句，编译器假定此<code>lambda</code>返回<code>void</code>，可使用尾置<code>-&gt;</code>指定返回类型；</li>
<li>【11】参数绑定：<code>auto newCallable = bind(callable, arg_list);</code>
其中使用_n表示<code>newCallable</code>的第n个参数（需要<code>using namespace std::placeholders</code>）；使用<code>ref</code>函数和<code>cref</code>函数（<code>#include &lt;functional&gt;</code>）返回的对象实现引用参数绑定，如：<code>auto g = bind(f, a, ref(b), _2, c, _1);</code>（注：此特性新版本已被弃用，建议直接使用lambda）；</li>
<li>插入迭代器<code>back_inserter it = vec</code>在<code>it = t</code>时会<code>push_back(t)</code>，<code>front_inserter</code>会<code>push_front(t)</code>（插入多个时会倒序插入），<code>inserter</code>在<code>*it = val</code>时等价于<code>it = c.insert(it, val); ++ it;</code></li>
<li>流迭代器：注意<code>istream_iterator</code>允许懒惰求值，知道使用迭代器时才真正读取；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>, eof</span>; <span class="comment">// 默认被定义为空对象，故可以用做尾后迭代器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)</span><br><span class="line">	vec.<span class="built_in">push_back</span>(*in_iter++);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>; <span class="comment">// 每输出一次后跟一个空格</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e: vec)</span><br><span class="line">	*out_iter++ = e; <span class="comment">// 事实上*和++不对out_iter做任何事，可以省略</span></span><br></pre></td></tr></table></figure>
<ul>
<li>反向迭代器<code>rptr.base()</code>实际为<code>rptr</code>的后一个，以统一左闭右开区间；</li>
<li>泛型算法可能要求的五类迭代器：输入、输出、前向、双向、随机访问；能力更强的迭代器可以传给能力更弱的形参，反之报错；标准库提供的泛型算法见附录A；</li>
<li>对于<code>list</code>和<code>forward_list</code>，应优先使用成员函数版本算法而非通用泛型算法；一般成员函数版本会改变容器及其迭代器，而通用函数不会；</li>
</ul>
<h3 id="第十一章-关联容器">第十一章 关联容器</h3>
<ul>
<li>【11】可以使用比较函数定义关联容器：<code>multiset&lt;T, decltype(compareT)*&gt;</code>，第二个为函数指针；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type;</span><br><span class="line">set&lt;string&gt; key_type; <span class="comment">// 与value_type相同</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type; <span class="comment">// 即pair&lt;const key_type, mapped_type&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一般不对关联容器使用泛型算法（键值是const也意味着不能修改）；</li>
<li>面向迭代器的查找遍历：<code>lower_bound(</code>)、<code>upper_bound()</code>和<code>equal_range()</code>；</li>
<li>【11】无序关联容器：<code>unordered_map</code>、<code>unordered_set</code>、<code>unordered_multimap</code>、<code>unordered_multiset</code>；支持一系列桶接口、桶迭代和哈希策略函数；</li>
</ul>
<h3 id="第十二章-动态内存">第十二章 动态内存</h3>
<ul>
<li>【11】C++11新特性支持智能指针<code>shared_ptr</code>、<code>unique_ptr</code>和前者的伴随类<code>weak_ptr</code>；</li>
<li><code>make_shared&lt;T&gt;(args)</code>和<code>shared_ptr&lt;T&gt;p(q)</code>
定义，编译期使用引用计数智能判定是否销毁指针指向的值并返还内存；当前指针设为<code>nullptr</code>将递减原对象引用计数，可以使用<code>reset()</code>销毁对象（注意别的指向此对象的指针）；</li>
<li>空悬指针是<code>delete</code>之后仍然指向原对象地址的指针，相当于野指针；不要混用智能指针和普通指针；</li>
<li>用<code>make_unique&lt;T&gt;(args)</code>
（11不支持）或<code>unique_ptr&lt;T&gt; p(new int(42));</code>
定义<code>unique_ptr</code>，不能拷贝和赋值（但可以作为函数参数和返回值）；用<code>unique_ptr&lt;int&gt; p2(p1.release())</code>或<code>p2 = move(p1)</code>或<code>p2.reset(p1.release())</code>转移对象所有权（p1、p2均交出当前所有权，并将p1所有权交给p2）；</li>
<li><code>weak_ptr&lt;T&gt; p(sp)</code>定义<code>weak_ptr</code>，不增加对象的引用计数，不阻止管理对象的销毁，用<code>p.use_count()</code>返回共享对象数量，<code>p.expired()</code>返回<code>use_count()</code>是否为0，用<code>lock()</code>在<code>expired</code>时返回空<code>shared_ptr</code>，否则返回指向p的对象的<code>shared_ptr</code>；</li>
<li>不应使用旧规范的动态数组，而应使用<code>vector</code>；使用<code>vector&lt;int&gt;().swap(vec);</code>释放<code>vec</code>空间；</li>
<li><code>allocator</code>类分离了内存分配和对象构造：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;T&gt; a;</span><br><span class="line">p = a.<span class="built_in">allocate</span>(n);</span><br><span class="line">a.<span class="built_in">deallocate</span>(p, n) <span class="comment">// 要求p和n必须都是allocate时的</span></span><br><span class="line">a.<span class="built_in">construct</span>(p, args);</span><br><span class="line">a.<span class="built_in">destroy</span>(p)；</span><br></pre></td></tr></table></figure>
<ul>
<li>【11】<code>construct</code>在旧标准中<code>args</code>必须传入一个元素类型值，C++11中可以使用多个构造函数参数初始化，如<code>a.construct(q++, 3, 'c')</code>令<code>*q</code>为<code>"ccc"</code>；</li>
<li>对为构造部分进行初始化，copy函数返回初始化范围的后一个尾置指针；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uninitialized_copy</span>(b, e, b2)</span><br><span class="line"><span class="built_in">uninitialized_copy_n</span>(b, n, b2)</span><br><span class="line"><span class="built_in">uninitialized_fill</span>(b, e, t)</span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(b, n, t)</span><br></pre></td></tr></table></figure>
<h2 id="第三部分-类设计者的工具">第三部分 类设计者的工具</h2>
<h3 id="第十三章-拷贝控制">第十三章 拷贝控制</h3>
<ul>
<li>三/五法则：五种拷贝控制操作特殊成员函数：拷贝构造、拷贝赋值、析构、移动构造、移动赋值，前三个可以控制类的拷贝操作；常常是否需要自定义拷贝构造和拷贝赋值就看是否需要析构函数；</li>
<li>拷贝构造函数<code>T(const T&amp;)</code>；默认合成拷贝构造函数将参数成员逐个拷贝到当前对象中；</li>
<li>直接初始化选取最符合的构造函数，可能调用拷贝构造函数；拷贝初始化可能进行类型转换；拷贝构造函数可以布置一个参数，但必须带默认参数；</li>
<li>拷贝初始化发生：使用<code>=</code>定义变量时；函数传递值参、返回
值类型时；使用C++11的花括号列表时的部分类类型；<code>emplace</code>都进行直接初始化；</li>
<li>重载拷贝赋值运算符：<code>T&amp; operator =(const T &amp;)</code>；合成析构函数不会<code>delete</code>它的指针成员，重载析构函数：<code>T::~T()</code>；</li>
<li>给函数传递类类型对象时，除了常规作用域查找外还会查找实参类所属的命名空间；当自定义和<code>std::</code>有命名冲突时，默认使用自定义函数；不提倡使用<code>using</code>而应该在每个使用标准库函数时均添加<code>std::</code>；</li>
<li>标准库容器、string和shared_ptr既支持移动又支持拷贝，IO类和unique_ptr类可以移动但不能拷贝；</li>
<li>【11】右值引用可以被绑定到要求转换的表达式、字面常量或返回右值的表达式；头文件<code>utility</code>中<code>move()</code>返回给定对象的右值引用，即承诺除了赋值和销毁外不会再使用原左值，定义移动构造函数：<code>T (T&amp;&amp; other)</code>；定义移动赋值函数：<code>T&amp; operator=(T&amp;&amp; other)</code></li>
<li><code>forward</code>和<code>move</code>不可以<code>using</code>，必须带<code>std::</code>
；</li>
</ul>
<h3 id="第十四章-重载运算与类型转换">第十四章 重载运算与类型转换</h3>
<ul>
<li>使用含有状态的函数对象类：可以被作为参数传入泛型算法，如<code>for_each(vs.begin(), vs.end(), PrintString(cerr,'\n'))</code>
；lambda是函数对象；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">	<span class="title">PrintString</span><span class="params">(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>)</span>:os(o), sep(c)&#123;</span>&#125; <span class="comment">// 定义了构造函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span><span class="type">const</span></span>&#123; os &lt;&lt; s &lt;&lt; sep; &#125; <span class="comment">// 定义了函数调用运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ostream &amp;os;</span><br><span class="line">	<span class="type">char</span> sep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>【11】C++11支持标准库<code>function</code>类型；</li>
<li>类型转换运算符：<code>[explicit] operator int() const;</code></li>
<li>表示运算符的模板对象类：<code>greater&lt;int&gt;()</code>等；</li>
</ul>
<h3 id="第十五章-面向对象程序设计">第十五章 面向对象程序设计</h3>
<ul>
<li>【11】C++11允许在参数列表后使用<code>override</code>关键字显式注明覆盖了继承的虚函数；</li>
<li>静态成员即使被继承也只存在唯一实例；</li>
<li>【11】在类名后使用<code>final</code>关键字防止继承；</li>
<li>不存在从基类向派生类的隐式类型转换；派生类向基类的转换只对指针和引用有效；</li>
<li>可以使用作用域运算符指定使用的虚函数；</li>
<li>名字查找先于类型检查；在构造函数和析构函数中使用的虚函数就是此函数所在的类的虚函数，而非动态类型的虚函数；</li>
<li>如果一个类会被派生，应该将其析构函数定义为虚函数；</li>
</ul>
<h3 id="第十六章-模板与泛型编程">第十六章 模板与泛型编程</h3>
<ul>
<li>有关模板、实例化、包扩展、转发、特例化、<code>std::move</code>
等内容；</li>
<li>推荐阅读 <strong><em>Effective Modern C++</em></strong>，<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/649667647">缩略版</a>；</li>
<li><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/455848360">关于移动语义</a>；</li>
</ul>
<h2 id="第四部分-高级主题">第四部分 高级主题</h2>
<h3 id="第十七章-标准库特殊设施">第十七章 标准库特殊设施</h3>
<ul>
<li>【11】<code>tuple</code>类似<code>pair</code>但成员数量任意（固定），定义为<code>tuple&lt;T1, T2, ..., Tn&gt; t(v1, v2, ..., vn)</code>或<code>make_tuple(v1, v2, ..., vn)</code>
；<code>get&lt;i&gt;(t)</code>返回<code>t</code>的第i个成员的引用（<code>t</code>为左值则返回左值引用，右值则右值引用）；拆包：<code>std::tie(gpa, grade, name) = make_tuple(3.8, 'A', "张三");</code></li>
<li>两个辅助类模板：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> T</span>;</span><br><span class="line"><span class="type">size_t</span> sz = tuple_size&lt;T&gt;::value;</span><br><span class="line">tuple_element&lt;<span class="number">1</span>, T&gt;::type cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bitset&lt;n&gt; b(u)</code> 定义<code>bitset</code>；</li>
<li>【11】<code>regex</code>类定义在<code>regex</code>头文件中，表示一个正则表达式；使用的是ECMAScript正则表达式语言，具体使用略；</li>
<li>【11】随机数引擎类和随机数分布类用法：<code>default_random_engine e; uniform_int_distribution&lt;unsigned&gt; u(0, 9);</code>
<code>e</code>是引擎类，<code>u</code>是分布类，用<code>u(e)</code>
返回一个随机数；具体使用略；</li>
<li>【11】C++风格IO格式控制略；C++11新增了十六进制浮点数等格式操作；</li>
</ul>
<h3 id="第十八章-用于大型程序的工具">第十八章 用于大型程序的工具</h3>
<ul>
<li>异常处理之栈展开：沿函数嵌套调用链查找对应<code>catch</code>子句，若为找到调用标准库函数<code>terminate</code>
，沿着调用链创建的对象将被销毁；</li>
<li>【11】紧跟函数参数列表之后的<code>noexcept</code>标识该函数不会抛出异常，与同样位置写<code>throw()</code>等价；<code>catch(...)</code>捕获所有异常，常常做部分处理后重新抛出throw空语句（会沿调用链向上传递）；</li>
<li>命名空间可以不连续；旧C++使用static表示文件级变量，文件外不可访问，新C++应使用未命名名字空间；</li>
<li>多重继承，使用虚继承解决菱形继承问题；</li>
</ul>
<h3 id="第十九章-特殊工具与技术">第十九章 特殊工具与技术</h3>
<ul>
<li>重载<code>new</code>和<code>delete</code>控制内存分配：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>)</span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="built_in">delete</span>(<span class="type">void</span>*) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行时类型识别（Run-Time Type
Identification，RTTI）：使用基类对象指针或引用执行派生类非虚函数时使用；<code>dynamic_cast&lt;type*/type&amp;/type&amp;&amp;&gt;(e)</code>
在转换失败时返回空指针或抛出<code>bad_cast</code>异常；<code>typeid(e)</code>返回运行时类型判断；</li>
<li>析构函数销毁对象但不释放内存；</li>
<li>枚举成员是<code>const</code>，可用<code>enum class</code>或<code>enum struct</code>限定作用域；限定作用域的枚举必须加上作用域限定符访问，且不会进行隐式转换；</li>
<li>【11】C++11中可以指定enum的大小：<code>enum big: unsigned long long</code>，且允许前置声明；</li>
<li>成员指针：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contents;</span><br><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>union</code>：节省空间的类，一次只有一个成员有效；匿名<code>union</code>的成员在<code>union</code>定义所在作用域可以被直接访问；</li>
</ul>
<h3 id="个人注记">个人注记</h3>
<p><a
target="_blank" rel="noopener" href="https://changkun.de/modern-cpp/zh-cn/01-intro/">现代C++教程：快速上手C++
11/14/17/20</a></p>
<ul>
<li>现代C++不再允许将字符串字面值常量赋值给<code>char *</code>，应该使用<code>const char *</code>；</li>
<li><code>unexpected_handler</code>、<code>set_unexpected()</code>被弃用，应使用<code>noexcept</code>；</li>
<li><code>auto_ptr</code>被弃用，应使用<code>unique_ptr</code>；</li>
<li><code>register</code>
被弃用，若一个类有析构函数，不再自动生成拷贝构造函数和拷贝赋值运算符；</li>
<li>C++17弃用了<code>&lt;ccomplex&gt;</code>；</li>
<li>使用<code>extern "C"</code>
分离代码中的C代码和C++代码，再用clang++链接.o文件；（<a
target="_blank" rel="noopener" href="https://changkun.de/modern-cpp/zh-cn/01-intro/#1-2-%E4%B8%8E-C-%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7">见此</a>）</li>
<li>C++14之后实现了泛型函数版本的<code>begin()</code>、<code>end()</code>等，建议使用；</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/19/Cousera%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Cousera吴恩达机器学习笔记">
      <i class="fa fa-chevron-left"></i> Cousera吴恩达机器学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/12/C-%E9%83%A8%E5%88%86%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/" rel="next" title="C++ 部分心得总结">
      C++ 部分心得总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E9%9B%B6%E9%83%A8%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">第零部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%A7%8B"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 开始</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-c%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">第一部分 C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">第二章 变量和基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text">第三章 字符串、向量和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">第四章 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.4.</span> <span class="nav-text">第五章 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">第六章 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB"><span class="nav-number">2.6.</span> <span class="nav-text">第七章 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-c%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">第二部分 C++标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-io%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">第八章 IO库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">第九章 顺序容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">第十章 泛型算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">第十一章 关联容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">3.5.</span> <span class="nav-text">第十二章 动态内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">4.</span> <span class="nav-text">第三部分 类设计者的工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">4.1.</span> <span class="nav-text">第十三章 拷贝控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.2.</span> <span class="nav-text">第十四章 重载运算与类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.3.</span> <span class="nav-text">第十五章 面向对象程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">第十六章 模板与泛型编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">第四部分 高级主题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD"><span class="nav-number">5.1.</span> <span class="nav-text">第十七章 标准库特殊设施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">5.2.</span> <span class="nav-text">第十八章 用于大型程序的工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="nav-number">5.3.</span> <span class="nav-text">第十九章 特殊工具与技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%B3%A8%E8%AE%B0"><span class="nav-number">5.4.</span> <span class="nav-text">个人注记</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="HocRiser"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">HocRiser</p>
  <div class="site-description" itemprop="description">平凡即是喜乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/HocRiser01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HocRiser01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hocriser@gmail.com" title="E-Mail → mailto:hocriser@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/GGN_2015" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;GGN_2015" rel="noopener" target="_blank">GGN_2015</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yirannn.com/" title="https:&#x2F;&#x2F;yirannn.com&#x2F;" rel="noopener" target="_blank">Yirannn</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://oceanpresent.art/" title="https:&#x2F;&#x2F;oceanpresent.art&#x2F;" rel="noopener" target="_blank">OceanPresent</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atoposyz.github.io/" title="https:&#x2F;&#x2F;atoposyz.github.io&#x2F;" rel="noopener" target="_blank">Atoposyz</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">皖ICP备2023012352号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HocRiser</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">214k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">6:29</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
