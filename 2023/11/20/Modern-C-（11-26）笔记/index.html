<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="robots" content="noindex, nofollow">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"47.99.133.133","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="堆、栈、RAII、容器  delete 一个空指针是合法的，但不能多次 delete； 手写智能指针：先实现一个 auto_ptr（赋值为移动语义），再定义引用计数类；每个智能指针类包含两个类的指针：引用技术类和对象类； 异常安全的赋值函数：复制并交换；  1234T&amp; operator&#x3D; (T rhs) &amp;#123;	rhs.swap(*this);	return *this;&amp;#125">
<meta property="og:type" content="article">
<meta property="og:title" content="Modern C++（11~26）笔记">
<meta property="og:url" content="http://47.99.133.133/2023/11/20/Modern-C-%EF%BC%8811-26%EF%BC%89%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="朝汐">
<meta property="og:description" content="堆、栈、RAII、容器  delete 一个空指针是合法的，但不能多次 delete； 手写智能指针：先实现一个 auto_ptr（赋值为移动语义），再定义引用计数类；每个智能指针类包含两个类的指针：引用技术类和对象类； 异常安全的赋值函数：复制并交换；  1234T&amp; operator&#x3D; (T rhs) &amp;#123;	rhs.swap(*this);	return *this;&amp;#125">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-11-20T22:48:44.000Z">
<meta property="article:modified_time" content="2023-11-20T10:04:19.320Z">
<meta property="article:author" content="HocRiser">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://47.99.133.133/2023/11/20/Modern-C-%EF%BC%8811-26%EF%BC%89%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Modern C++（11~26）笔记 | 朝汐</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">朝汐</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">如星空般深蓝</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fa fa-image fa-fw"></i>Gallery</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/HocRiser01" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://47.99.133.133/2023/11/20/Modern-C-%EF%BC%8811-26%EF%BC%89%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="HocRiser">
      <meta itemprop="description" content="平凡即是喜乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝汐">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Modern C++（11~26）笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-11-20 17:48:44 / Modified: 05:04:19" itemprop="dateCreated datePublished" datetime="2023-11-20T17:48:44-05:00">2023-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="堆栈raii容器">堆、栈、RAII、容器</h2>
<ul>
<li><code>delete</code> 一个空指针是合法的，但不能多次
<code>delete</code>；</li>
<li>手写智能指针：先实现一个
<code>auto_ptr</code>（赋值为移动语义），再定义引用计数类；每个智能指针类包含两个类的指针：引用技术类和对象类；</li>
<li>异常安全的赋值函数：复制并交换；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>= (T rhs) &#123;</span><br><span class="line">	rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vector</code> 保证强异常安全性，如果没有 <code>noexcept</code>
的移动构造函数，会调用拷贝构造函数；</li>
<li><code>queue</code> 和 <code>stack</code>
依赖现有容器，因此称为容器适配器，默认均为 <code>deque</code>
实现；</li>
<li><code>less</code> 和 <code>greater</code> 均为通过重载同名结构体的
<code>bool operator() (const T&amp; x, const T&amp; y)</code>
得到的函数对象；它们继承的 <code>binary_function</code> 和
<code>unary_function</code> 已在 C++11 被废弃；</li>
</ul>
<span id="more"></span>
<h2 id="右值引用和移动语义">右值引用和移动语义</h2>
<ul>
<li>生命周期延长：若一个 prvalue
被绑定到一个引用上，其生命周期会被延长至引用变量的生命周期；</li>
<li>C++11 后的移动语义使
<code>string str = string("Hello") + name + "."</code> 这样的语句调用
<code>operator+(const string&amp;&amp;, const string&amp; / const char*)</code>
从而减少了拷贝次数；</li>
<li>实现五个特殊成员函数时应尽量带上 <code>noexcept</code> ；</li>
<li>右值引用类型的变量本身是左值；</li>
<li>返回值优化
NRVO：在一些简单条件下会直接在栈上构造对象，从而减少拷贝次数；</li>
<li><strong>xvalue</strong>
是一个可以被移动的值，并且与某个存储位置关联（如通过
<code>std::move</code> 生成的已命名对象）；<strong>prvalue</strong>
是一个纯粹的值，不与任何存储位置关联（如一个整数字面值或一个计算的结果）；<strong>glvalue
(generalized lvalue)</strong> 包括 lvalue 和
xvalue；<strong>rvalue</strong>: 包括 xvalue 和 prvalue。</li>
<li><code>decltype&lt;auto&gt;</code> 推导规则：
<ul>
<li><em>prvalue</em>（例如临时变量）推导出 <em>type</em>；</li>
<li><em>lvalue</em>（例如有名字的对象）推导出 <em>type&amp;</em>；</li>
<li><em>xvalue</em>（例如用 std::move()标记的对象）推导出
<em>type&amp;&amp;</em>；</li>
</ul></li>
</ul>
<h2 id="异常">异常</h2>
<ul>
<li>声明了 <code>noexcept</code> 的函数抛出异常会直接导致
<code>std::terminate</code> ；</li>
<li>特殊成员函数若内部调用的函数均为 <code>noexcept</code> ，则本身也为
<code>noexcept</code> ；</li>
<li>异常安全的四个等级：
<ul>
<li>无异常安全：抛出异常会进入未定义状态；</li>
<li>基本异常安全：抛出异常保证处于一致状态，但不保证保持原始状态（有副作用）；</li>
<li>强异常安全：抛出异常将回滚；</li>
<li>不抛异常安全：不抛异常；</li>
</ul></li>
</ul>
<h2 id="其它">其它</h2>
<ul>
<li>一个迭代器必然支持 <code>++</code> 和 <code>*</code> ，若支持
<code>*</code> 输出则为输出迭代器；若支持 <code>*</code>
读取则为输入迭代器，再可反复读取则为前向迭代器，再支持 <code>--</code>
则为双向迭代器，再支持跳跃和比较则为随机访问迭代器，若还保证对象在内存连续存放则为连续迭代器（C++20）；</li>
<li>C++11 会尽量使用移动返回对象，C++17
允许返回不可拷贝、不可移动的对象：直接构造于目标位置；新标准之后，应尽量使用返回值而非参数返回对象；</li>
<li>C++11 引入了 <code>char16_t</code> 和 <code>char32_t</code>
，分别代表 UTF-16 和 UTF-32；C++20 引入了用于存储 UTF-8 的
<code>char8_t</code> ；</li>
</ul>
<h2 id="自动类型推断字面量静态断言">自动类型推断、字面量、静态断言</h2>
<ul>
<li>C++17 之后 <code>array</code> 可以不带 <code>&lt;int, 3&gt;</code>
而使用自动推断了；也允许使用
<code>auto [lower, upper] = Map.equal_range("four");</code></li>
<li>C++11 允许使用大括号初始化列表在成员变量定义时默认初始化；</li>
<li>C++11 允许使用 <code>operator ""</code>
定义下划线开头的字面量；</li>
<li>C++14 支持 <code>0b</code> 表示二进制字面量，支持在数字中添加
<code>'</code> 使其更可读；</li>
<li>C++11 提供静态断言
<code>static_assert(condition, output_info)</code>
，可以直接在类定义中使用；</li>
</ul>
<h2 id="编译期多态泛型编程与模板">编译期多态、泛型编程与模板</h2>
<ul>
<li>模板元编程提供图灵完备的类型推导；</li>
<li>使用静态成员变量储存 value， <code>typedef</code> 储存 type；</li>
<li>使用替换失败非错（SFINAE）和 <code>enable_if</code>
实现条件编译；</li>
<li><code>declval&lt;T&gt;</code> 为类型 T
创建一个假设的右值引用，而不实际构造该类型的对象；它只有声明因此只能用于编译时上下文；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integral_constant</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> T value = v;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> integral_constant type;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;<span class="type">bool</span>, <span class="literal">true</span>&gt; true_type;</span><br><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;<span class="type">bool</span>, <span class="literal">false</span>&gt; false_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable_if：仅当 B 为 true 时拥有 type；</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> enable_if &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, T&gt; &#123; <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsIntegral</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> IsIntegral : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsIntegral</span>&lt;T, std::<span class="type">enable_if_t</span>&lt;std::is_integral&lt;T&gt;::value&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo_integral</span>(T value) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo_not_integral</span>(T value) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// has_reserve</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_reserve : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_reserve</span>&lt;T, <span class="keyword">typename</span> std::enable_if&lt;<span class="literal">true</span>, <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">reserve</span>(<span class="number">1</span>))&gt;::type&gt;</span><br><span class="line">        : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数式编程可变模板和-tuple-的编译期技巧">函数式编程、可变模板和
<code>**tuple**</code> 的编译期技巧</h2>
<ul>
<li><code>[this]</code> 按引用捕获外围对象， <code>[*this]</code>
按值捕获，调用拷贝（C++17）；</li>
<li>lambda 表达式可以取代 <code>bind</code>；</li>
<li>Map 在 C++ 中对应 <code>transform</code> ，Reduce 在 C++ 中对应
<code>accumulate</code> （C++17 已有 <code>reduce()</code>
，要求归并操作的交换律和结合律，Filter 在 C++ 中对应
<code>copy_if</code> 和 <code>partition</code> ；</li>
<li>实现 Compose：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(F f, Args... other)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> [f, other...](<span class="keyword">auto</span>&amp;&amp;... x) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">compose</span>(other...)(forward&lt;<span class="keyword">decltype</span>(x)&gt;(x)...));</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>简化版 <code>std::integer_sequence</code> 和
<code>index_sequence</code> （C++14）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integer_sequence</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">using</span> index_sequence = integer_sequence&lt;<span class="type">size_t</span>, Ints...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">index_sequence_helper</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> index_sequence_helper&lt; N - <span class="number">1</span>, N - <span class="number">1</span>, Ints...&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">index_sequence_helper</span>&lt;<span class="number">0</span>, Ints...&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> index_sequence&lt;Ints...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> make_index_sequence = <span class="keyword">typename</span> index_sequence_helper&lt;N&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>, <span class="type">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">apply_impl</span><span class="params">(F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">get</span>&lt;I&gt;(forward&lt;Tuple&gt;(t))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">apply</span><span class="params">(F&amp;&amp; f, Tuple&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">apply_impl</span>(forward&lt;F&gt;(f), forward&lt;Tuple&gt;(t),</span><br><span class="line">		make_index_sequence&lt;tuple_size_v&lt;<span class="type">remove_reference_t</span>&lt;Tuple&gt;&gt;&gt;&#123;&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c14-新特性">C++14 新特性</h2>
<p><a
target="_blank" rel="noopener" href="https://github.com/AnthonyCalandra/modern-cpp-features#user-defined-literals-for-standard-library-types">C++11，14，17，20
特性总结（英文）</a></p>
<ul>
<li>放宽 <code>constexpr</code> 限制；</li>
<li>支持变量模板（ <code>constexpr T pi = T(3.14)</code>
）、别名模板（泛型关联：给模板定义类型起别名）与变参模板（参数个数可变）；</li>
<li>支持 <code>auto</code> 参数的泛型 lambda、lambda 初始化捕获；</li>
<li>支持返回类型推导、 <code>decltype&lt;auto&gt;</code> ；</li>
<li>聚合初始化（用初始化列表初始化结构体）、 <code>make_unique()</code>
；</li>
<li>二进制字面量 <code>0b110</code> 、整型字面量分隔符
<code>12'345</code>；</li>
<li>透明比较扩展：支持 <code>std::set</code> 和 <code>std::map</code>
两个比较数不是同一类型，从而可以用 <code>const char*</code> 查找
<code>std::set&lt;std::string&gt;</code> ；</li>
<li><code>std::shared_timed_mutex</code> 与
<code>std::shared_lock</code> 等；</li>
<li><code>[[deprecated]]</code> 、 <code>std::get</code> 获取元组元素、
使用移动语义的<code>std::exchange</code> ；</li>
</ul>
<h2 id="c17-新特性">C++17 新特性</h2>
<p><a
target="_blank" rel="noopener" href="https://github.com/0voice/cpp_new_features/blob/main/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%EF%BC%9AC%2B%2B17%E6%96%B0%E7%89%B9%E6%80%A7.md">C++17
特性总结</a></p>
<ul>
<li>结构化绑定
<ul>
<li>可以使用 <code>auto [u, v] = myStruct</code> 、
<code>auto [u, v] &#123;myStruct&#125;</code> 或
<code>auto [u, v] (myStruct)</code> 解构对象；也可以用在
<code>for (const auto&amp; [key, val] : myMap)</code> 中；</li>
<li>本质上是匿名本地拷贝了 <code>myStruct</code> （假设为 <code>e</code>
）， <code>u</code> 和 <code>v</code> 分别是 <code>e</code>
的成员，若使用 <code>auto&amp;</code> ，则 <code>e</code>
为原对象引用，即修饰符并非作用于 <code>u</code> 和 <code>v</code>
；</li>
<li>结构化绑定同样也适用于原生数组、 <code>std::array</code> 、
<code>std::pair</code> 和 <code>std::tuple</code>
不会产生类型退化；</li>
</ul></li>
<li>属性
<ul>
<li><code>[[nodiscard]]</code>
：鼓励编译期在返回值未被使用时给警告；</li>
<li><code>[[maybe_unused]]</code>
：避免编译期在返回值未被使用时给警告；</li>
<li><code>[[fallthrough]]</code> ：避免编译期在 <code>switch</code>
语句某个标签缺少 <code>break</code> 时给警告；</li>
<li><code>[[deprecated]]</code> ：弃用；</li>
</ul></li>
<li>带初始化的 <code>if</code> 和 <code>switch</code> 语句：类似
<code>for</code> ，可以使用 <code>auto</code>
，定义变量仅在此语句中有效；</li>
<li>在头文件中使用 <code>inline static</code> <em>定义</em>
全局变量（必须直接初始化，且必须是字面类型）；现在
<code>static constexpr</code> 修饰符隐含 <code>inline</code> ；</li>
<li>聚合体可以拥有基类；C++17 中数组和满足一定条件的 <em>类类型</em>（
<code>class</code> 、 <code>struct</code> 、 <code>union</code>
）均被认为是 <em>聚合体</em>；</li>
<li>强制省略拷贝或传递未实质化（从 <em>prvalue</em> 转化为
<em>xvalue</em>）的对象：比具名返回值优化（NRVO）更强，可以在
<code>delete</code> 禁止拷贝和移动函数的情况下工作；</li>
<li>进一步放宽 lambda 和 <code>constexpr</code> 范围，支持
<code>constexpr</code> lambda；</li>
<li>嵌套命名空间；</li>
<li>解决了部分表达式求值顺序无保证的问题；</li>
<li>C++17 之后直接初始化 <code>auto a&#123;42&#125;</code> 会得到 <code>int</code>
，拷贝初始化 <code>auto a = &#123;42&#125;</code> 会得到
<code>initializer_list</code> ；</li>
<li><code>u8'6'</code> 表示 UTF-8 字符字面量；</li>
<li>异常声明将作为函数类型的一部分；</li>
<li>自动类模板参数推导；支持 <code>std::pair p(a, b)</code> 而不需
<code>make_pair</code> ；</li>
<li>使用编译期 <code>if</code> 语句 <code>if constexpr(...)</code>
在编译期决定生成 <code>then</code> 还是 <code>else</code> 的代码；</li>
<li>折叠表达式：有一些处理空参数包的规则；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (... + args);</span><br><span class="line"><span class="keyword">return</span> (args + ... + <span class="number">0</span>);</span><br><span class="line">(..., <span class="built_in">foo</span>(forward&lt;T&gt;args));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Node* <span class="title">traverse</span><span class="params">(T np, TP... paths)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (np ‐&gt;* ... ‐&gt;* paths); <span class="comment">// np ‐&gt;* paths1 ‐&gt;* paths2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对模板能力的进一步扩展，可以使用 <code>auto</code> 和
<code>decltype&lt;auto&gt;</code> 作模板参数；</li>
<li>类型擦出容器和代数数据类型：
<ul>
<li><code>std::optional&lt;T&gt;</code> 在空时为
<code>std::nullopt</code> ；</li>
<li><code>std::variant&lt;int, double, std::string&gt;</code> ，更安全的
<code>union</code> ；</li>
<li><code>std::any</code>
不需提前声明存储哪些类型，在取值时才通过模板参数指定，更安全的
<code>void*</code>；</li>
<li><code>std::any</code> 、 <code>std::optionalstd::variant</code>
均为值语义，赋值时执行深拷贝；</li>
</ul></li>
<li>字符串视图 <code>std::string_view</code>
：一段字符串的引用，不具有所有权，具备 <code>std::string</code>
所有只读接口；</li>
<li><code>std::apply(func, std::tuple(...))</code>
将容器值作为函数输入；</li>
<li>C++17 采纳了 Boost.Filesystem 提供文件系统库，在
<code>std::filesystem</code> 下；</li>
<li>支持类型特征后缀：可用 <code>_v</code> 代替 <code>::value</code>
；</li>
<li>支持使用 <code>std::execution::par</code> 调用并行 STL 能力，需要
<em>tbb</em> 库；</li>
<li>新增泛型辅助函数 <code>size()</code> 、 <code>empty</code> 、
<code>data()</code> ；</li>
<li><code>clamp()</code> 找到三个值中居中的那个； <code>sample()</code>
获取一个随机子集；</li>
<li><code>emplace()</code> 系函数现在返回新插入对象的引用；
<code>try_emplace(&#123;key, std::move(value)&#125;)</code> 在插入成功时才会移动；
<code>insert_or_assign()</code> 无则插入有则替换，必然移动；</li>
<li><code>std::vector</code> 、 <code>std::list</code> 和
<code>std::forward_list</code>
开始支持不完全类型（可以在一个类中声明本身类型的 <code>vector</code>
作为成员变量）；</li>
<li>提供 <code>std::scoped_lock&lt;&gt;</code>
同时锁住多个互斥量，<code>std::shared_mutex&lt;&gt;</code>
支持读写锁，是 C++14 的 <code>std::shared_timed_mutex&lt;&gt;</code>
的子集；</li>
<li><code>m.extract()</code>
提取一个容器（可以用迭代器或键值指定），返回一个
<code>std::map&lt;Key, T&gt;::node_type</code> ，此时 <code>m</code>
不再包含此值；</li>
<li><code>&lt;numeric&gt;</code> 中新增 <code>std::gcd()</code> 和
<code>std::lcm()</code> ；</li>
<li>大量新增算法 API、专家特性与辅助特性；</li>
<li>数字与字符串互转：C++11 有 <code>std::to_string()</code> 和
<code>std::stoi()</code> ，C++17 新增 <code>std::from_chars()</code> 和
<code>std::to_chars()</code> ；</li>
<li>C++14 兼容 C99，而 C++17 兼容 C11；</li>
<li>C++11 废除空异常声明 <code>throw()</code> ，C++17 废除动态异常声明
<code>throw(std::bad_alloc)</code> ；</li>
<li><code>register</code> C++17 起不再有语义，但关键字仍然保留；</li>
<li>禁止 <code>bool</code> 使用 <code>++</code> ，移除
<code>auto_ptr</code> ；移除 <code>random_shuffle()</code> ，使用
<code>std::shuffle()</code> 代替；</li>
<li>移除 <code>std::unary_function</code> 和
<code>std::binary_function</code> ；</li>
</ul>
<h2 id="c20-新特性">C++20 新特性</h2>
<p><a
target="_blank" rel="noopener" href="https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%2020%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.md">C++20
特性总结</a></p>
<ul>
<li>格式化输出：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">format(<span class="string">&quot;Hello &#123;1&#125; &#123;0&#125;&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;first&quot;</span>); <span class="comment">// Hello first second</span></span><br><span class="line">format(<span class="string">&quot;&#123;:.5&#125;, &#123;:.&lt;5&#125;&quot;</span>, <span class="number">3.14159</span>, <span class="number">42</span>); <span class="comment">// 3.1416, 42...</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>进一步放宽 <code>constexpr</code> 范围；</p></li>
<li><p><code>&lt;utility&gt;</code> 使用 <code>cmp_less()</code>
等比较两个不同类型的数；</p></li>
<li><p>“宇宙飞船” <code>&lt;=&gt;</code> ：</p>
<ul>
<li>返回一个 <code>&lt;compare&gt;</code> 中的对象，可以与 0
比较；若小于则返回值小于 0，大于则大于 0，等于则等于 0；</li>
<li>若操作数为整型，则返回
<code>strong_ordering::equal/less/greater</code> ；若为浮点型，返回
<code>partial_ordering::equivalent/less/greater/unordered</code> ；</li>
<li><code>&lt;=&gt;</code> 重载</li>
<li>C++20 后会将 <code>a &gt; b</code> 重写为
<code>b &lt;=&gt; a &lt; 0</code> ，因此可以直接通过重载
<code>auto operator&lt;=&gt;(const Num&amp;) const = default;</code>
省去列举每个比较操作符的重载（默认按定义顺序依次将每个变量作为关键字），而只需再重载
<code>==</code> ；</li>
</ul></li>
<li><p>协程（Coroutines）：</p>
<ul>
<li>无栈协程，使用 <code>co_return</code> 、 <code>co_await</code> 、
<code>co_yield</code> ；</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample 1</span></span><br><span class="line"><span class="function">generator&lt;<span class="type">int</span>&gt; <span class="title">range</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> start;</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// co_return;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sample 2</span></span><br><span class="line"><span class="function">task&lt;<span class="type">void</span>&gt; <span class="title">echo</span><span class="params">(socket s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> data = <span class="keyword">co_await</span> s.<span class="built_in">async_read</span>();</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(s, data)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// co_return;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>概念</strong>（Concepts）：</p>
<ul>
<li><code>requires Numeric&lt;T&gt;</code> 约束（任意）模板，其中
<code>concept Numeric = integral&lt;T&gt; || floating_point&lt;T&gt;;</code>
；运算数结果为 <code>bool</code> ，结果需要为 <code>true</code> ；</li>
<li>可以直接写 <code>template &lt;Numeric T&gt;</code> ，或写入参数
<code>auto func(Numeric auto &amp;arg);</code> ；</li>
<li>可以在函数、 <code>lambda</code>
中使用；三种约束的逻辑操作符：合取式（conjunctions）、析取式（disjunctions）、原子约束（atomic
constraints），使用短路；</li>
<li>以下代码可以一定程度代替虚函数，提供更好的 ABI 稳定性：</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="keyword">concept</span> DerivedOfBaseClass = std::is_base_of_v&lt;BaseClass, T&gt;;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Histogram = <span class="built_in">requires</span>(T h1, T h2) &#123;</span><br><span class="line">    h1.<span class="built_in">getMoments</span>();         <span class="comment">// 要求有getMoments接口</span></span><br><span class="line">    T::count;                <span class="comment">// 要求有静态变量count</span></span><br><span class="line">    h1.moments;              <span class="comment">// 要求有成员变量moments</span></span><br><span class="line">    h1 + h2;                 <span class="comment">// 要求对象能够进行+操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> T::type;        <span class="comment">// 要求存在类型成员type</span></span><br><span class="line">    <span class="keyword">typename</span> std::vector&lt;T&gt;; <span class="comment">// 要求能够模板实例化并与std::vector组合使用</span></span><br><span class="line">    </span><br><span class="line">    &#123; h1.<span class="built_in">getSubHistogram</span>() &#125; -&gt; same_as&lt;T&gt;;    <span class="comment">// 要求接口返回类型与T一致</span></span><br><span class="line">    &#123; h1.<span class="built_in">getUnit</span>() &#125; -&gt; convertible_to&lt;<span class="type">float</span>&gt;; <span class="comment">// 要求接口返回类型能转换成float，本质上接口返回类型可能是double</span></span><br><span class="line">    &#123; h1 = std::<span class="built_in">move</span>(h2) &#125; <span class="keyword">noexcept</span>;          <span class="comment">// 要求表达式不能抛出异常</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">requires</span> <span class="title">sizeof</span><span class="params">(T)</span> &gt; 4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>模块</strong>（Modules）：</p>
<ul>
<li>一个编译单元默认为普通单元，使用 <code>module</code>
则为模块单元；使用 <code>export module my_module</code>
的称为模块接口单元（对应传统头文件），使用 <code>module my_module</code>
称为模块实现单元（对应传统实现文件）；使用 <code>import my_module</code>
导入模块；</li>
<li>需要在函数签名、命名空间等前使用 <code>export</code> 对外公开；使用
<code>export import one_module</code> 重导出模块（类似 Rust 中的
<code>pub use</code> ）；</li>
<li>若模块单元需要 <code>#include&lt;&gt;</code>
，或其它全局代码段，则需要在开头写一句 <code>module;</code>
引入全局模块，然后写预处理指令，写完后立即声明一个标准模块
<code>export module my_module</code> ；</li>
<li>实现部分和接口部分可以放在同一个文件中，接口部分前使用
<code>export module my_module</code> ，实现部分前使用
<code>module: private</code> ；</li>
<li>模块分区： <code>module A:B;</code> ，导入时只需要指定分区名称：
<code>export import :A;</code> ；模块分区的所有声明均对模块本身公开，
<code>export</code>
使其<strong><em>可以</em></strong>对模块外公开，但最终还需要主模块接口单元决定，即模块分区单元中的符号必须通过主模块的接口单元使用
<code>export</code> 控制对外可见性；</li>
<li>可以使用 <code>A.B</code> 式模块名，但与 <code>A</code>
之间并没有父子模块关系；</li>
<li>Module 并没有解决符号冲突问题，仍然需要与 namespace
配合使用，二者保持正交设计；同样不能解决二进制分发与 ABI 对齐问题；</li>
</ul></li>
<li><p><strong>范围</strong>（Ranges）：</p>
<ul>
<li>Range 是一个 Concept，要求是可迭代对象的集合，且支持
<code>begin()</code> 和 <code>end()</code> 迭代器；</li>
<li><strong>视图</strong>是惰性迭代操作，从底层返回而不拥有任何数据，复杂度为
O(1)；</li>
<li>使用 <code>ranges::take_view(ranges, n)</code> 返回前 n
个元素的视图，支持只读操作，同时支持 <code>for (int i: tv)</code>
；</li>
<li>视图适配器对函数式编程的支持：视图管道
<code>auto ****result = nums | views::take(5) | views::reverse;</code>
获取 <code>nums</code> 前五个元素的翻转；</li>
<li><code>nums | views::filter(lambda)</code> ，
<code>nums | views::transform(lambda)</code> ；
<code>views::reverse()</code> ， <code>views::iota(1, 10)</code>
返回一系列递增值；</li>
<li><code>stack</code> 和 <code>queue</code> 没有 <code>begin()</code>
和 <code>end()</code> ；</li>
<li><code>ranges::sort(vec)</code> ， <code>views::drop(view)</code>
；</li>
</ul></li>
<li><p><code>std::span</code> ：C 数组的 <code>string_view</code>
；直接用 <code>std::span&lt;T&gt;</code> 传参将 C 数组升级为
<code>span</code> ，从而传递其长度，且支持 <code>begin()</code> 、
<code>front()</code> 、 <code>empty()</code>
等操作；注意它仍不检查越界；</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> remove_it = std::<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), v); <span class="comment">// 返回后面向前移动后的末尾下一个</span></span><br><span class="line">c.<span class="built_in">erase</span>(remove_it, c.<span class="built_in">end</span>()); <span class="comment">// 真正的删除</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>[[likely]]</code> 和 <code>[[unlikely]]</code>
标记某个分支走到的概率；</li>
<li>不建议隐式捕获 <code>[=]</code> 捕获 <code>this</code>
，已弃用；使用 <code>[=, this]</code> 显式捕获；</li>
<li><code>lambda</code> 中可以使用模板语法，可以捕获参数包；
<code>[&amp;...args = std::forward&lt;Args&gt;(args)] &#123;...&#125;</code>
；</li>
<li><code>&lt;bit&gt;</code> 头提供位操作； <code>&lt;numbers&gt;</code>
头中定义一些数学常量；</li>
<li><code>std::make_shared&lt;int[]&gt;(5)</code> 或
<code>std::make_shared&lt;int[5]&gt;()</code> 支持数组；</li>
<li><code>str.starts_with("foo")</code> 和 <code>ends_with()</code> ；
<code>map</code> 和 <code>set</code> 新增 <code>contains(key)</code>
；</li>
<li><code>std::midpoint(1, 3) == 2</code> 不溢出地计算两个值的中点；
<code>std::to_array</code> 将 array-like 对象转换为
<code>std::array</code> ；</li>
<li>新增一系列新库函数； <code>jthread</code> ；编译时源代码分析
<code>source_location</code> 库； <code>u8string</code> ；</li>
</ul>
<h2 id="c23-新特性">C++23 新特性</h2>
<ul>
<li>显式 <code>this</code> 参数： <code>this Self&amp; self</code>
，搭配模板实现同时定义函数的 const 和非 const 版本，也可以实现递归
lambda 函数；</li>
<li>多元 <code>operator[]</code>
：支持逗号分隔的多维下标，可以搭配参数包转发；同时提供多维数组视图
<code>mdspan</code> ，可以用于包装一维数组模拟多维数组；</li>
<li>标准模块 <code>std</code> 与 <code>std.compact</code> ；</li>
<li><code>unexpected()</code> 、 <code>and_then</code> 、
<code>or_else</code> 等借鉴自 Rust 等语言的函数，错误码类型类似
optional；</li>
<li>进一步扩展 Ranges：转换函数 <code>to</code> ；</li>
<li><code>print()</code> 和 <code>println()</code> ：配合
<code>format</code> 输出；</li>
<li>堆栈跟踪库 <code>stacktrace</code> ；</li>
<li>C++26 新特性（猜测）：
<ul>
<li>静态反射；</li>
<li>Executors：获取线程池对象，并分配任务；</li>
<li>Sender / Receiver：Sender 创建后不立即执行调度任务，传递给 Receiver
后在执行；支持使用通用异步算法实现链式调用；Scheduler 返回 Sender
工厂；</li>
<li>标准网络库 Network；</li>
<li>高性能计算（线性代数等）；</li>
<li>Coroutines 扩展： <code>std::lazy</code> ；</li>
<li>进一步扩展 Ranges；</li>
<li>Hive：Bucket Array
容器框架，用于高性能交易、游戏编程等场景的大量数据块操作；</li>
<li>多线程无锁内存模型；</li>
<li>CPO
定制点对象：若引入的命名空间中仅有一个此函数名则无需写命名空间前缀；</li>
</ul></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/21/The-Rust-Programming-Language-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="prev" title="The Rust Programming Language 读书笔记">
      <i class="fa fa-chevron-left"></i> The Rust Programming Language 读书笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/20/Pine-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="next" title="Pine 源码阅读笔记">
      Pine 源码阅读笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%A0%88raii%E5%AE%B9%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">堆、栈、RAII、容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">右值引用和移动语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">3.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">4.</span> <span class="nav-text">其它</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%AD%97%E9%9D%A2%E9%87%8F%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="nav-number">5.</span> <span class="nav-text">自动类型推断、字面量、静态断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.</span> <span class="nav-text">编译期多态、泛型编程与模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%92%8C-tuple-%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E6%8A%80%E5%B7%A7"><span class="nav-number">7.</span> <span class="nav-text">函数式编程、可变模板和
**tuple** 的编译期技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">C++14 新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">9.</span> <span class="nav-text">C++17 新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c20-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">C++20 新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c23-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">11.</span> <span class="nav-text">C++23 新特性</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="HocRiser"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">HocRiser</p>
  <div class="site-description" itemprop="description">平凡即是喜乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/HocRiser01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HocRiser01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hocriser@gmail.com" title="E-Mail → mailto:hocriser@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/GGN_2015" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;GGN_2015" rel="noopener" target="_blank">GGN_2015</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yirannn.com/" title="https:&#x2F;&#x2F;yirannn.com&#x2F;" rel="noopener" target="_blank">Yirannn</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://oceanpresent.art/" title="https:&#x2F;&#x2F;oceanpresent.art&#x2F;" rel="noopener" target="_blank">OceanPresent</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atoposyz.github.io/" title="https:&#x2F;&#x2F;atoposyz.github.io&#x2F;" rel="noopener" target="_blank">Atoposyz</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">皖ICP备2023012352号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HocRiser</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">205k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">6:13</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
